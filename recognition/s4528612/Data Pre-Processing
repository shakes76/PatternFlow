
import re

import tensorflow as tf
import random, os
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import tensorflow.keras as keras
from tensorflow.keras import layers
left = 0
right = 0
labels = []
image_data = []
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        if re.search('right', filename.replace("_",""), re.IGNORECASE):
            right += 1
            labels.append(1)
        else:
            left += 1
            labels.append(0)
        image_data.append(img_to_array(load_img(dirname+"/"+filename,
                target_size=(73, 64),
                color_mode="grayscale")))
print(left)
print(right)


#Cross Attention Layer
def cross_attention(image_size):
    
    # Number of Pixels in the Scaled Image
    print(image_size)
    latent_input = layers.Input(shape=(256, 2*(2*6 + 1) + 1))
    data_array_input = layers.Input(shape=(image_size, 2*(2*6 + 1) + 1))

    latent_array = layers.LayerNormalization(epsilon=1e-6)(latent_input)
    data_array = layers.LayerNormalization(epsilon=1e-6)(data_array_input)

    query_key_value_vector = []
    

    query_key_value_vector.append(layers.Dense(units=2*(2*6 + 1) + 1)(latent_array))
    for _ in range(2):
        query_key_value_vector.append(layers.Dense(units=2*(2*6 + 1) + 1)(data_array))

    attention = layers.Attention(use_scale=True, dropout=0.1)(
        query_key_value_vector
    )
    attention = layers.Add()([attention, latent_array])

    attention = layers.LayerNormalization(epsilon=1e-6)(attention)
    
    # Feedforward network.
    feedforward_network = [] # May need to add more layers
    feedforward_network.append(layers.Dense(units=2*(2*6 + 1) + 1))
    outputs = keras.Sequential(feedforward_network)(attention)
    
    outputs = layers.Add()([outputs, attention])

    return keras.Model(inputs=[latent_input,data_array_input], outputs=outputs)

model = cross_attention(73*64, 2*(2*6 + 1) + 1)
model.summary()

#Reshape The Fourier Encoder to The array shape then performe calculation
def fourier_encode(array):
    encode = tf.reshape(tf.experimental.numpy.logspace(
            start=0.0,
            stop=math.log(10 / 2) / math.log(10),
            num=10,
            dtype=tf.float32,
        ),((len(array.shape) - 1), 4))
    return 3.14 * array * encode